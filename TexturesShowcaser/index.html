<!DOCTYPE html>
<html>
<head>
<title>Textures Showcaser</title>
<link rel="stylesheet" href="styles.css">
</head>
<body onload="javascript:initialize()">

<center>
<h1>Textures Showcaser</h1>

<div id="xmlLoad">
<input type="file" accept=".xml" id="xmlInput" name="files" />
</div>

<div id="path" class="path">
	Current folder :<br><div id="currentPath"></div>
</div>
<br>
<br>
<br>
<br>

<output id="list"></output>
</center>

<br>
<div id="footer" class="footer">
Textures Showcaser is a tool built in conjuction to TexturesXMLExporter, by <a href="mailto:konsnosl@gmail.com?Subject=TexturesShowcaser" target="_top">Konstantinos Egkarchos</a>.
</div>

<script>
	// create the nodeType constants if the Node object is not defined
	if (!window.Node)
	{
		var Node =
		{
			ELEMENT_NODE                :  1,
			ATTRIBUTE_NODE              :  2,
			TEXT_NODE                   :  3,
			CDATA_SECTION_NODE          :  4,
			ENTITY_REFERENCE_NODE       :  5,
			ENTITY_NODE                 :  6,
			PROCESSING_INSTRUCTION_NODE :  7,
			COMMENT_NODE                :  8,
			DOCUMENT_NODE               :  9,
			DOCUMENT_TYPE_NODE          : 10,
			DOCUMENT_FRAGMENT_NODE      : 11,
			NOTATION_NODE               : 12
		}
	}

	document.getElementById('xmlInput').addEventListener('change', handleFileSelect, false);

	// If api is supported this is true.
	var apiSupported;
	// If xml is laoded this is true.
	var xmlLoaded;

	var xmlFile;
	var xmlDomDoc;
	var nodeNamesDepth;

	function CallMe()
	{
		window.open("file:C:/Users/konsn_000/Dropbox/Shared_kEgk_gSag/TexturesXMLExporter/Clean_Storage_Crate/Wood_CommonStorageCrate_1k_TGA");
	}
	
	function initialize()
	{
		document.getElementById("path").style.display = 'none';
		
		supportsFileAPI();
	}

	function supportsFileAPI()
	{
		// Check for the various File API support.
		if (window.File && window.FileReader && window.FileList && window.Blob) 
		{
			apiSupported = true;
		  	// Great success! All the File APIs are supported.
		  	console.log("File, FileReader, FileList and Blob are supported.");
		} 
		else 
		{
			apiSupported = false;
		  	alert("This browser doesn't support the required functions.");

		  	// Hide all page
		  	document.getElementById("xmlLoad").style.display = 'none';
		  	document.getElementById("list").style.display = 'none';
		}
	}

	function handleFileSelect(evt)
	{
		xmlFile = evt.target.files[0]; // FileList object
		xmlLoaded = false;

		checkXMLValidity();
	}

	function checkXMLValidity()
	{
		if (xmlFile && xmlFile.type == "text/xml")
		{
			document.getElementById("xmlLoad").style.display = 'none';
		}
		else
		{
			alert("Failed to load file.");
		}

		// test
		var reader = new FileReader();
		waitForTextReadComplete(reader);
		reader.readAsText(xmlFile);
	}

	function waitForTextReadComplete(reader)
	{
	    reader.onloadend = function(event)
	    {
	        var text = event.target.result;

	        parseTextAsXml(text);
	    }
	}

	function parseTextAsXml(text)
	{
	    var parser = new DOMParser();
	    xmlDomDoc = parser.parseFromString(text, "text/xml");
	    xmlLoaded = true;

	    //now, extract items from xmlDomDoc and assign to appropriate text input fields
	    nodeNamesDepth = [xmlDomDoc.documentElement.nodeName];
	    nodeNamesDepth = ["Texs", "TexturesXMLExporter", "TexturesXMLExporter", "Paneled_Wood_Wall", "Wall_WoodPanel_1k_TGA"];

	    xmlLoadedSuccessfully();
	}
	
	function xmlLoadedSuccessfully()
	{
		document.getElementById("path").style.display = 'block';
		showCurrentFolderContents();
	}

	/** Test function to traverse the whole xml node tree. */
	function traverse(tree) 
	{
		if(tree.hasChildNodes()) 
		{ 
			document.write('<ul><li>');
			document.write('<b>' + tree.tagName + '</b>');
			var nodes=tree.childNodes.length;
			for(var i=0; i<tree.childNodes.length; i++)
				traverse(tree.childNodes[i]);
			document.write('</li></ul>'); 
		}
	}

	/** Finds inside a node the required name from the attributes. */
	function findName (node, name) 
	{
		var childNodes = node.childNodes;
		for (var i = 0; i < childNodes.length; i++)
		{
			// Check if node and if folder.
			if (childNodes[i].nodeType == Node.ELEMENT_NODE && childNodes[i].nodeName == "folder")
			{
				// Check if it is the name we are searching for
				if (childNodes[i].getAttribute('name') == name)
				{
					// return it
					return childNodes[i];
				}
			}
		}

		console.log("Houston, we have a problem");
		return null;
	}

	/** Return all maps contained in the node. */
	function getMaps (node) 
	{
		var childNodes = node.childNodes;
		var maps = [];

		for (var cn = 0; cn < childNodes.length; cn++) 
		{
			// Handle maps
			if (childNodes[cn].nodeType == Node.ELEMENT_NODE && childNodes[cn].nodeName == "map")
			{
				maps.push(childNodes[cn].getAttribute('thumb'));
			}
			// Handle materials
			if (childNodes[cn].nodeType == Node.ELEMENT_NODE && childNodes[cn].nodeName == "material")
			{
				var newMaps = getMaps(childNodes[cn]);
				maps = maps.concat(newMaps);
			}
		}
		
		return maps;
	}

	function showCurrentFolderContents()
	{
		var nestedNode = xmlDomDoc.getElementsByTagName(nodeNamesDepth[0])[0];
		
		var path = nestedNode.getAttribute("path");
		for(var p = 1;p < nodeNamesDepth.length;p++)
		{
			path += "\\" + nodeNamesDepth[p];
		}
		document.getElementById("currentPath").innerHTML = path; 

		//traverse(nestedNode);
		
		for (var i = 1; i < nodeNamesDepth.length; i++)
		{
			nestedNode = findName(nestedNode, nodeNamesDepth[i]);
		}

		showMaps(getMaps(nestedNode));
	}
	
	function showMaps(maps)
	{
		console.log("Showing " + maps.length + " maps.");
		// Render thumbnail.
		var span = document.createElement('span');
		var innerHtml = "";
		
		for(var m = 0;m<maps.length;m++)
		{
			innerHtml += '<img class="thumb" src="' + maps[m] + '"/>';
		}
		span.innerHTML = innerHtml;
		
		document.getElementById('list').insertBefore(span, null);
	}
</script>

</body>
</html>